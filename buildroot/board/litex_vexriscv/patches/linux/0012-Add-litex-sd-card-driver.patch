From 6cd31283d71f845c08c86fe0c05cd9c552830699 Mon Sep 17 00:00:00 2001
From: Mariusz Glebocki <mglebocki@antmicro.com>
Date: Fri, 16 Aug 2019 14:57:26 +0200
Subject: [PATCH 1/2] Add litex sd card driver

---
 arch/riscv/boot/dts/litex-vexriscv-linux.dtsi |   15 +
 arch/riscv/boot/dts/litex_vexriscv.dts        |    1 +
 arch/riscv/configs/litex_defconfig            |    4 +
 drivers/mmc/core/sd.c                         |    2 +-
 drivers/mmc/host/Kconfig                      |    6 +
 drivers/mmc/host/Makefile                     |    1 +
 drivers/mmc/host/litex_mmc.c                  | 1271 +++++++++++++++++
 7 files changed, 1299 insertions(+), 1 deletion(-)
 create mode 100644 drivers/mmc/host/litex_mmc.c

diff --git a/arch/riscv/boot/dts/litex-vexriscv-linux.dtsi b/arch/riscv/boot/dts/litex-vexriscv-linux.dtsi
index a9983428c..9ef2ec90b 100644
--- a/arch/riscv/boot/dts/litex-vexriscv-linux.dtsi
+++ b/arch/riscv/boot/dts/litex-vexriscv-linux.dtsi
@@ -54,5 +54,20 @@
 			reg = <0x0 0xf0001000 0x0 0x100>;
 			status = "okay";
 	   	};
+
+		mmc0: mmc@f0005000 {
+			compatible = "litex,mmc";
+			bus-width = <4>;
+			reg = <
+				0 0xf0003000 0 0x100 /* sdclk csr */
+				0 0xf0005000 0 0x100 /* sdcore csr */
+				0 0xf0006000 0 0x100 /* sddatareader csr */
+				0 0xf0006800 0 0x100 /* sddatawriter csr */
+				0 0xb0002000 0 0x200 /* sdread */
+				0 0xb0002200 0 0x200 /* sdwrite */
+				0 0xf0005800 0 0x100 /* sdtimer csr */
+			>;
+			status = "okay";
+		};
 	};
 };
diff --git a/arch/riscv/boot/dts/litex_vexriscv.dts b/arch/riscv/boot/dts/litex_vexriscv.dts
index 0be285b52..65ca32600 100644
--- a/arch/riscv/boot/dts/litex_vexriscv.dts
+++ b/arch/riscv/boot/dts/litex_vexriscv.dts
@@ -6,6 +6,7 @@
 
 	chosen {
 		bootargs = "mem=32M@0x40000000 rootwait console=liteuart root=/dev/ram0 init=/sbin/init swiotlb=32";
+		/* bootargs = "mem=32M@0x40000000 rootwait console=liteuart root=/dev/ram0 init=/sbin/init swiotlb=32 dyndbg=\"file drivers/mmc/core/* +pfl \" dmesg loglevel=8"; */
 		linux,initrd-start = <0xC0800000>;
 		linux,initrd-end   = <0xC1000000>; // max 8MB ramdisk image
 	};
diff --git a/arch/riscv/configs/litex_defconfig b/arch/riscv/configs/litex_defconfig
index b9868eb18..a5e15056c 100644
--- a/arch/riscv/configs/litex_defconfig
+++ b/arch/riscv/configs/litex_defconfig
@@ -437,6 +437,10 @@ CONFIG_OF_MDIO=y
 # CONFIG_OF_OVERLAY is not set
 # CONFIG_PARPORT is not set
 CONFIG_BLK_DEV=y
+#
+#LiteX MMC
+CONFIG_MMC_LITEX=y
+#
 # CONFIG_BLK_DEV_NULL_BLK is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_DRBD is not set
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d0d9f90e7..cff8ff40e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -117,7 +117,7 @@ static int mmc_decode_csd(struct mmc_card *card)
 		m = UNSTUFF_BITS(resp, 99, 4);
 		e = UNSTUFF_BITS(resp, 96, 3);
 		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
-		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12) | CCC_BLOCK_WRITE;
 
 		e = UNSTUFF_BITS(resp, 47, 3);
 		m = UNSTUFF_BITS(resp, 62, 12);
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index a44ec8bb5..9aa72e907 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -999,3 +999,9 @@ config MMC_SDHCI_AM654
 	  If you have a controller with this interface, say Y or M here.
 
 	  If unsure, say N.
+
+config MMC_LITEX
+	tristate "Support for the MMC Controller in LiteX SOCs"
+	depends on OF
+	help
+	  Generic MCC driver for LiteX
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 73578718f..8e1ee337b 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -97,6 +97,7 @@ obj-$(CONFIG_MMC_SDHCI_BRCMSTB)		+= sdhci-brcmstb.o
 obj-$(CONFIG_MMC_SDHCI_OMAP)		+= sdhci-omap.o
 obj-$(CONFIG_MMC_SDHCI_SPRD)		+= sdhci-sprd.o
 obj-$(CONFIG_MMC_CQHCI)			+= cqhci.o
+obj-$(CONFIG_MMC_LITEX)			+= litex_mmc.o
 
 ifeq ($(CONFIG_CB710_DEBUG),y)
 	CFLAGS-cb710-mmc	+= -DDEBUG
diff --git a/drivers/mmc/host/litex_mmc.c b/drivers/mmc/host/litex_mmc.c
new file mode 100644
index 000000000..5f72f9b64
--- /dev/null
+++ b/drivers/mmc/host/litex_mmc.c
@@ -0,0 +1,1271 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Antmicro <www.antmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sizes.h>
+#include <linux/fs.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/core.h>
+#include <linux/clk.h>
+#include <linux/genhd.h>
+#include <linux/of.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/genhd.h>
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/pm_runtime.h>
+#include <linux/mmc/slot-gpio.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+
+struct sdclk_regs {
+	u32 mmcm_reset[1];
+	u32 mmcm_read[1];
+	u32 mmcm_write[1];
+	u32 mmcm_drdy[1];
+	u32 mmcm_adr[1];
+	u32 mmcm_dat_w[2];
+	u32 mmcm_dat_r[2];
+};
+
+struct sdcore_regs {
+	u32 argument[4];
+	u32 command[4];
+	u32 issue_cmd[1];
+	u32 response[15];
+	u32 cmdevt[4];
+	u32 dataevt[4];
+	u32 blocksize[2];
+	u32 blockcount[4];
+	u32 datatimeout[4];
+	u32 cmdtimeout[4];
+	u32 datawcrcclear[1];
+	u32 datawcrcvalids[4];
+	u32 datawcrcerrors[4];
+};
+
+struct sddatareader_regs {
+	u32 reset[1];
+	u32 start[1];
+	u32 done[1];
+	u32 errors[4];
+};
+
+struct sddatawriter_regs {
+	u32 reset[1];
+	u32 start[1];
+	u32 done[1];
+};
+
+struct sdtimer_regs {
+	u32 load[4];
+	u32 reload[4];
+	u32 en[1];
+	u32 update_value[1];
+	u32 value[4];
+	u32 ev_status[1];
+	u32 ev_pending[1];
+	u32 ev_enable[1];
+};
+
+#define CSR_SDCLK_BASE 0xf0003000L
+#define CSR_SDCLK_MMCM_RESET_OFFSET 0x00L
+#define CSR_SDCLK_MMCM_RESET_SIZE 1
+#define CSR_SDCLK_MMCM_READ_OFFSET 0x04L
+#define CSR_SDCLK_MMCM_READ_SIZE 1
+#define CSR_SDCLK_MMCM_WRITE_OFFSET 0x08L
+#define CSR_SDCLK_MMCM_WRITE_SIZE 1
+#define CSR_SDCLK_MMCM_DRDY_OFFSET 0x0cL
+#define CSR_SDCLK_MMCM_DRDY_SIZE 1
+#define CSR_SDCLK_MMCM_ADR_OFFSET 0x10L
+#define CSR_SDCLK_MMCM_ADR_SIZE 1
+#define CSR_SDCLK_MMCM_DAT_W_OFFSET 0x14L
+#define CSR_SDCLK_MMCM_DAT_W_SIZE 2
+#define CSR_SDCLK_MMCM_DAT_R_OFFSET 0x1cL
+#define CSR_SDCLK_MMCM_DAT_R_SIZE 2
+
+#define SYSTEM_CLOCK_FREQUENCY (u32)1e8
+#define SD_CLOCK_FREQUENCY (u32)10 //In MHz
+#define MAX_CCNT ((1 << 16) - 1)
+#define MAX_NR_SG 1
+#define RW_THRESHOLD 32
+
+#define SDCARD_CTRL_DATA_TRANSFER_NONE  0
+#define SDCARD_CTRL_DATA_TRANSFER_READ  (1 << 5)
+#define SDCARD_CTRL_DATA_TRANSFER_WRITE (2 << 5)
+
+#define SDCARD_CTRL_RESPONSE_NONE  0
+#define SDCARD_CTRL_RESPONSE_SHORT 1
+#define SDCARD_CTRL_RESPONSE_LONG  2
+
+#define SD_SPEED_SDR12  0
+#define SD_SPEED_SDR25  1
+#define SD_SPEED_SDR50  2
+#define SD_SPEED_SDR104 3
+#define SD_SPEED_DDR50  4
+
+#define SD_OK 0
+#define SD_CRCERROR 1
+#define SD_TIMEOUT 2
+#define SD_WRITEERROR 3
+
+#define SD_GROUP_COMMANDSYSTEM  1
+#define SD_GROUP_DRIVERSTRENGTH 2
+#define SD_GROUP_POWERLIMIT     3
+
+#define SD_DRIVER_STRENGTH_B 0
+#define SD_DRIVER_STRENGTH_A 1
+#define SD_DRIVER_STRENGTH_C 2
+#define SD_DRIVER_STRENGTH_D 3
+
+
+static int dbg_stfu = 1;
+
+#define mlog(fmt, ...) if(!dbg_stfu) {printk(KERN_ERR"\033[32m[sd] \033[1m"fmt"\033[0m\n", ## __VA_ARGS__);}else{}
+#define mlogid() if(!dbg_stfu) {printk(KERN_ERR"\033[31m[sd] \033[1m" "%s:%d" "\033[0m\n", __func__, __LINE__);}else{}
+
+struct litex_mmc_host {
+	struct mmc_host *mmc;
+	struct platform_device *dev;
+
+	struct {
+		__iomem struct sdclk_regs *sdclk;
+		__iomem struct sdcore_regs *sdcore;
+		__iomem struct sddatareader_regs *sddatareader;
+		__iomem struct sddatawriter_regs *sddatawriter;
+		__iomem struct sdtimer_regs *sdtimer;
+	} regs;
+	__iomem u8 *sdread;
+	__iomem u8 *sdwrite;
+
+	u32 resp[4];
+	u16 rca;
+
+	unsigned clock;
+	unsigned char bus_width;
+	bool is_bus_width_set;
+	bool app_cmd;
+};
+
+struct litex_mmc_config {
+	int (*get_cd)(int module);
+	int (*get_ro)(int module);
+	void (*set_power)(int module, bool on);
+	u32 max_freq;
+	u32 caps;
+	u8 nr_sg;
+};
+
+static void sdclk_mmcm_write(unsigned int adr, unsigned int data)
+{
+	volatile u8 *ptr = (volatile u8 *)CSR_SDCLK_BASE;
+	iowrite32(adr, ptr + CSR_SDCLK_MMCM_ADR_OFFSET);
+
+	iowrite32(data >> 8, ptr + CSR_SDCLK_MMCM_DAT_W_OFFSET);
+	iowrite32(data, ptr + CSR_SDCLK_MMCM_DAT_W_OFFSET + 0x04);
+	iowrite32(1, ptr + CSR_SDCLK_MMCM_WRITE_OFFSET);
+
+	while (!ioread32(ptr + CSR_SDCLK_MMCM_DRDY_OFFSET))
+		;
+}
+
+//**********************************************
+//LITESDCARD CODE FOR CLK CONFIG FROM ENJOY-DIGITAL REPO
+
+static void sdclk_set_config(unsigned int m, unsigned int d)
+{
+	/* clkfbout_mult = m */
+	if (m % 2)
+		sdclk_mmcm_write(0x14, 0x1000 | ((m / 2) << 6) | (m / 2 + 1));
+	else
+		sdclk_mmcm_write(0x14, 0x1000 | ((m / 2) << 6) | m / 2);
+	/* divclk_divide = d */
+	if (d == 1)
+		sdclk_mmcm_write(0x16, 0x1000);
+	else if (d % 2)
+		sdclk_mmcm_write(0x16, ((d / 2) << 6) | (d / 2 + 1));
+	else
+		sdclk_mmcm_write(0x16, ((d / 2) << 6) | d / 2);
+	/* clkout0_divide = 10 */
+	sdclk_mmcm_write(0x8, 0x1000 | (5 << 6) | 5);
+	/* clkout1_divide = 2 */
+	sdclk_mmcm_write(0xa, 0x1000 | (1 << 6) | 1);
+}
+
+/* FIXME: add vco frequency check */
+static void sdclk_get_config(unsigned int freq, unsigned int *best_m,
+			     unsigned int *best_d)
+{
+	unsigned int ideal_m, ideal_d;
+	unsigned int bm, bd;
+	unsigned int m, d;
+	unsigned int diff_current;
+	unsigned int diff_tested;
+
+	ideal_m = freq;
+	ideal_d = 10000;
+
+	bm = 1;
+	bd = 0;
+	for (d = 1; d <= 128; d++)
+		for (m = 2; m <= 128; m++) {
+			/* common denominator is d*bd*ideal_d */
+			diff_current = abs(d * ideal_d * bm - d * bd * ideal_m);
+			diff_tested = abs(bd * ideal_d * m - d * bd * ideal_m);
+			if (diff_tested < diff_current) {
+				bm = m;
+				bd = d;
+			}
+		}
+	*best_m = bm;
+	*best_d = bd;
+}
+
+void sdclk_set_clk(unsigned int freq)
+{
+	unsigned int clk_m, clk_d;
+
+	sdclk_get_config(1000 * freq, &clk_m, &clk_d);
+	sdclk_set_config(clk_m, clk_d);
+}
+
+//**********************************************
+
+static void litex_mmc_read_rsp(struct litex_mmc_host *host, u32 resp[4])
+{
+	static const u8 reg_size = sizeof(host->regs.sdcore->response)/4;
+	unsigned offset;
+	unsigned i;
+	u8 value;
+
+	resp[0] = resp[1] = resp[2] = resp[3] = 0;
+
+	for (i = 0; i < reg_size; i++) {
+		offset = reg_size - 1 - i;
+		value = ioread32(&host->regs.sdcore->response[offset]) & 0xFF;
+		resp[sizeof(resp) - 1 - i/4] |= value << (8 * (i%4));
+	}
+}
+
+static void _write_reg(struct litex_mmc_host *host, u32 data, __iomem u32 *reg,
+		      u8 reg_size)
+{
+	u8 i;
+	for (i = 0; i < reg_size; i++) {
+		iowrite32(data >> (reg_size - 1 - i) * 8, &reg[i]);
+	}
+}
+#define write_reg(host, data, reg) _write_reg(host, data, reg, sizeof(reg)/4)
+
+static u32 _read_reg(struct litex_mmc_host *host, __iomem const u32 *reg,
+		     u8 reg_size)
+{
+	u32 value = 0;
+	u8 i;
+	for (i = 0; i < reg_size; i++) {
+		value <<= 8;
+		value |= ioread32(&reg[i]) & 0xFF;
+	}
+	return value;
+}
+#define read_reg(host, reg) _read_reg(host, reg, sizeof(reg)/4)
+
+static void busy_wait(unsigned int ms)
+{
+	if (ms <= 20)
+		usleep_range(ms * 1000, ms * 1250);
+	else
+		msleep(ms);
+}
+
+static void litex_issue_cmd(struct litex_mmc_host *host) {
+	write_reg(host, 1, host->regs.sdcore->issue_cmd);
+}
+
+static inline u32 read_cmdevt(struct litex_mmc_host *host) {
+	return read_reg(host, host->regs.sdcore->cmdevt);
+}
+
+static inline u32 read_dataevt(struct litex_mmc_host *host) {
+	return read_reg(host, host->regs.sdcore->dataevt);
+}
+
+static int sdcard_wait_cmd_done(struct litex_mmc_host *host) {
+	u32 cmdevt;
+	// TODO: add timeout
+	while (1) {
+		cmdevt = read_cmdevt(host);
+		mlog("    status: (cmdevt = %08x)", cmdevt);
+		if (cmdevt & 0x1) {
+			if (cmdevt & 0x4) {
+				mlog("    status: timeout");
+				return SD_TIMEOUT;
+			}
+			if (cmdevt & 0x8) {
+				mlog("    status: crcerror");
+				return SD_CRCERROR;
+			}
+			mlog("    status: ok");
+			return SD_OK;
+		}
+	}
+}
+
+static int sdcard_wait_data_done(struct litex_mmc_host *host) {
+	u32 dataevt;
+	while (1) {
+		dataevt = read_dataevt(host);
+		mlog("    data status: (dataevt = %08x)", dataevt);
+		if (dataevt & 0x1) {
+			if (dataevt & 0x4) {
+				mlog("    data status: timeout");
+				return SD_TIMEOUT;
+			}
+			if (dataevt & 0x8) {
+				mlog("    data status: crcerror");
+				return SD_CRCERROR;
+			}
+			mlog("    data status: ok");
+			return SD_OK;
+		}
+	}
+}
+
+static int send_cmd(struct litex_mmc_host *host, u8 cmd, u32 arg,
+		    u8 response_len, u8 transfer) {
+	int status = SD_OK;
+	unsigned done = 0;
+	mlogid();
+	mlog("    cmd %u arg %u (0x%08x) %s", cmd, arg, arg,
+	     transfer == SDCARD_CTRL_DATA_TRANSFER_READ ? "dataread" :
+	     transfer == SDCARD_CTRL_DATA_TRANSFER_WRITE ? "datawrite" :
+	     "");
+
+	if (transfer == SDCARD_CTRL_DATA_TRANSFER_READ) {
+		write_reg(host, 1, host->regs.sddatareader->reset);
+		write_reg(host, 1, host->regs.sddatareader->start);
+	} else if (transfer == SDCARD_CTRL_DATA_TRANSFER_WRITE) {
+		write_reg(host, 1, host->regs.sddatawriter->reset);
+		write_reg(host, 1, host->regs.sddatawriter->start);
+	}
+	write_reg(host, arg, host->regs.sdcore->argument);
+	write_reg(host, cmd << 8 | transfer | response_len,
+		  host->regs.sdcore->command);
+	litex_issue_cmd(host);
+	busy_wait(1);
+
+	status = sdcard_wait_cmd_done(host);
+	if (response_len != SDCARD_CTRL_RESPONSE_NONE) {
+		litex_mmc_read_rsp(host, host->resp);
+	}
+
+	if(status != SD_OK) {
+		return status;
+	}
+
+	if (!host->app_cmd && cmd == SD_SEND_RELATIVE_ADDR) {
+		host->rca = (host->resp[3] >> 16) & 0xffff;
+		mlog("    new rca: %04x", host->rca);
+	}
+
+	if (transfer) {
+		busy_wait(1);
+		status = sdcard_wait_data_done(host);
+
+		if(status != SD_OK) {
+			return status;
+		}
+
+
+		if (transfer == SDCARD_CTRL_DATA_TRANSFER_READ) {
+			while((done & 1) == 0) {
+				done = read_reg(host, host->regs.sddatareader->done);
+				mlog("    read done: %08x", done);
+			}
+		} else if (transfer == SDCARD_CTRL_DATA_TRANSFER_WRITE) {
+			while((done & 1) == 0) {
+				done = read_reg(host, host->regs.sddatawriter->done);
+				mlog("    write done: %08x", done);
+			}
+			busy_wait(100);
+		}
+	}
+
+	return status;
+}
+
+// CMD0
+static inline int send_go_idle_cmd(struct litex_mmc_host *host) {
+	mlogid();
+	return send_cmd(host, MMC_GO_IDLE_STATE, 0,
+			SDCARD_CTRL_RESPONSE_NONE,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD8
+static inline int send_send_ext_csd_cmd(struct litex_mmc_host *host) {
+	mlogid();
+	return send_cmd(host, MMC_SEND_EXT_CSD, 0x1aa,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD55
+static inline int send_app_cmd(struct litex_mmc_host *host) {
+	mlogid();
+	return send_cmd(host, MMC_APP_CMD, host->rca << 16,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// ACMD6
+static inline int send_app_set_bus_width_cmd(struct litex_mmc_host *host, u32 width) {
+	mlogid();
+	return send_cmd(host, SD_APP_SET_BUS_WIDTH, width,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// ACMD41
+static inline int send_app_op_cond_cmd(struct litex_mmc_host *host, int hcs, int s18r) {
+	u32 arg = 0x10ff8000;
+	mlogid();
+	if (hcs)
+		arg |= 0x60000000;
+	if (s18r)
+		arg |= 0x01000000;
+	return send_cmd(host, SD_APP_OP_COND, arg,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD3
+static inline int send_set_relative_address_cmd(struct litex_mmc_host *host, u16 rca) {
+	int status;
+	mlogid();
+	status =  send_cmd(host, SD_SEND_RELATIVE_ADDR, rca,
+			   SDCARD_CTRL_RESPONSE_SHORT,
+			   SDCARD_CTRL_DATA_TRANSFER_NONE);
+
+	if (status == SD_OK) {
+		host->rca = (host->resp[3] >> 16) & 0xffff;
+		mlog("    rca: %04x", host->rca);
+	}
+
+	return status;
+}
+
+static inline void mlog_print_cid(struct litex_mmc_host *host) {
+	mlog("        manufacturer id: 0x%04x", (host->resp[0] >> 16) & 0xffff)
+	mlog("        app id:          0x%04x", host->resp[0] & 0xffff)
+	mlog("        product name:    %c%c%c%c%c",
+		(host->resp[1] >> 24) & 0xff,
+		(host->resp[1] >> 16) & 0xff,
+		(host->resp[1] >>  8) & 0xff,
+		(host->resp[1] >>  0) & 0xff,
+		(host->resp[2] >> 24) & 0xff);
+}
+
+// CMD2
+static inline int send_all_send_cid_cmd(struct litex_mmc_host *host) {
+	int status;
+	mlogid();
+	status =  send_cmd(host, MMC_ALL_SEND_CID, 0,
+			   SDCARD_CTRL_RESPONSE_LONG,
+			   SDCARD_CTRL_DATA_TRANSFER_NONE);
+	mlog_print_cid(host);
+	return status;
+}
+
+// CMD10
+static inline int send_send_cid_cmd(struct litex_mmc_host *host) {
+	mlogid();
+	return send_cmd(host, MMC_SEND_CID, host->rca << 16,
+			SDCARD_CTRL_RESPONSE_LONG,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD9
+static inline int send_send_csd_cmd(struct litex_mmc_host *host) {
+	mlogid();
+	return send_cmd(host, MMC_SEND_CSD, host->rca << 16,
+			SDCARD_CTRL_RESPONSE_LONG,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD7
+static inline int send_select_card_cmd(struct litex_mmc_host *host) {
+	mlogid();
+	return send_cmd(host, MMC_SELECT_CARD, host->rca << 16,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD6
+static inline int send_switch_cmd(struct litex_mmc_host *host, u8 mode, u8 group,
+				  u8 value) {
+	const u32 arg = ((mode << 31) | 0xFFFFFF)
+			& ~(0xF << (group*4))
+			| (value << (group*4));
+	int status = SD_OK;
+	mlogid();
+	mlog("    cmd %u arg %u (0x%08x)", MMC_SWITCH, arg, arg);
+
+	write_reg(host, arg, host->regs.sdcore->argument);
+	write_reg(host, 64, host->regs.sdcore->blocksize);
+	write_reg(host, 1, host->regs.sdcore->blockcount);
+	write_reg(host, MMC_SWITCH << 8 | SDCARD_CTRL_DATA_TRANSFER_READ
+		  | SDCARD_CTRL_RESPONSE_SHORT, host->regs.sdcore->command);
+	litex_issue_cmd(host);
+
+	busy_wait(1);
+	status = sdcard_wait_cmd_done(host);
+	litex_mmc_read_rsp(host, host->resp);
+	if (status != SD_OK) {
+		return status;
+	}
+
+	busy_wait(1);
+	status = sdcard_wait_data_done(host);
+
+	return status;
+}
+
+// ACMD51
+static inline int send_app_send_scr_cmd(struct litex_mmc_host *host) {
+	int status = SD_OK;
+	mlogid();
+	mlog("    cmd %u arg %u (0x%08x)", SD_APP_SEND_SCR, 0, 0);
+
+	write_reg(host, 0, host->regs.sdcore->argument);
+	write_reg(host, 8, host->regs.sdcore->blocksize);
+	write_reg(host, 1, host->regs.sdcore->blockcount);
+	write_reg(host, SD_APP_SEND_SCR << 8 | SDCARD_CTRL_DATA_TRANSFER_READ
+		  | SDCARD_CTRL_RESPONSE_SHORT, host->regs.sdcore->command);
+	litex_issue_cmd(host);
+
+	busy_wait(1);
+	status = sdcard_wait_cmd_done(host);
+	litex_mmc_read_rsp(host, host->resp);
+	if (status != SD_OK) {
+		return status;
+	}
+
+	busy_wait(1);
+	status = sdcard_wait_data_done(host);
+
+	return status;
+}
+
+// CMD51
+static inline int send_set_blocklen_cmd(struct litex_mmc_host *host, u32 blocklen) {
+	mlogid();
+	return send_cmd(host, MMC_SET_BLOCKLEN, blocklen,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD23
+static inline int send_set_block_count(struct litex_mmc_host *host, u32 blockcount) {
+	mlogid();
+	return send_cmd(host, MMC_SET_BLOCK_COUNT, blockcount,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+// CMD17
+static inline int send_read_single_block(struct litex_mmc_host *host,
+					 u32 blockaddr)
+{
+	int status = -1;
+	mlogid();
+	mlog("    cmd %u arg %u (0x%08x)", MMC_READ_SINGLE_BLOCK, blockaddr, blockaddr);
+
+	while (status != SD_OK) {
+		write_reg(host, blockaddr, host->regs.sdcore->argument);
+		write_reg(host, 512, host->regs.sdcore->blocksize);
+		write_reg(host, 1, host->regs.sdcore->blockcount);
+		write_reg(host, MMC_READ_SINGLE_BLOCK << 8
+					 | SDCARD_CTRL_DATA_TRANSFER_READ
+					 | SDCARD_CTRL_RESPONSE_SHORT,
+					 host->regs.sdcore->command);
+		litex_issue_cmd(host);
+		status = sdcard_wait_cmd_done(host);
+	}
+
+	return sdcard_wait_data_done(host);
+}
+
+// CMD18
+static inline int send_read_multiple_block(struct litex_mmc_host *host,
+					 u32 blockaddr, u32 blockcount)
+{
+	int status = -1;
+	mlogid();
+	mlog("    cmd %u arg %u (0x%08x)", MMC_READ_MULTIPLE_BLOCK, blockaddr, blockaddr);
+
+	while (status != SD_OK) {
+		write_reg(host, blockaddr, host->regs.sdcore->argument);
+		write_reg(host, 512, host->regs.sdcore->blocksize);
+		write_reg(host, blockcount, host->regs.sdcore->blockcount);
+		write_reg(host, MMC_READ_MULTIPLE_BLOCK << 8
+					 | SDCARD_CTRL_DATA_TRANSFER_READ
+					 | SDCARD_CTRL_RESPONSE_SHORT,
+					 host->regs.sdcore->command);
+		litex_issue_cmd(host);
+		status = sdcard_wait_cmd_done(host);
+	}
+
+	return sdcard_wait_data_done(host);
+}
+
+// CMD25
+static inline int send_write_multiple_block_cmd(struct litex_mmc_host *host,
+					 u32 blockaddr, u32 blockcount)
+{
+	int status = -1;
+	mlogid();
+	mlog("    cmd %u arg %u (0x%08x)", MMC_WRITE_MULTIPLE_BLOCK, blockaddr, blockaddr);
+
+	while (status != SD_OK) {
+		write_reg(host, blockaddr, host->regs.sdcore->argument);
+		write_reg(host, 512, host->regs.sdcore->blocksize);
+		write_reg(host, blockcount, host->regs.sdcore->blockcount);
+		write_reg(host, MMC_WRITE_MULTIPLE_BLOCK << 8
+					 | SDCARD_CTRL_DATA_TRANSFER_WRITE
+					 | SDCARD_CTRL_RESPONSE_SHORT,
+					 host->regs.sdcore->command);
+		litex_issue_cmd(host);
+		status = sdcard_wait_cmd_done(host);
+	}
+
+	return sdcard_wait_data_done(host);
+}
+
+// CMD24
+static inline int send_write_single_block_cmd(struct litex_mmc_host *host,
+					      u32 blockaddr)
+{
+	int status = -1;
+	mlogid();
+	mlog("    cmd %u arg %u (0x%08x)", MMC_WRITE_BLOCK, blockaddr, blockaddr);
+
+	while (status != SD_OK) {
+		write_reg(host, blockaddr, host->regs.sdcore->argument);
+		write_reg(host, 512, host->regs.sdcore->blocksize);
+		write_reg(host, 1, host->regs.sdcore->blockcount);
+		write_reg(host, MMC_WRITE_BLOCK << 8
+			  | SDCARD_CTRL_DATA_TRANSFER_WRITE
+			  | SDCARD_CTRL_RESPONSE_SHORT,
+			  host->regs.sdcore->command);
+		litex_issue_cmd(host);
+		status = sdcard_wait_cmd_done(host);
+	}
+
+	return sdcard_wait_data_done(host);
+}
+
+// CMD12
+static inline int send_stop_transmission_cmd(struct litex_mmc_host *host) {
+	mlogid();
+	return send_cmd(host, MMC_STOP_TRANSMISSION, 0,
+			SDCARD_CTRL_RESPONSE_SHORT,
+			SDCARD_CTRL_DATA_TRANSFER_NONE);
+}
+
+static void litex_timer_init(struct litex_mmc_host *host)
+{
+	write_reg(host, 0, host->regs.sdtimer->en);
+	write_reg(host, 0xffffffff, host->regs.sdtimer->load);
+	write_reg(host, 0xffffffff, host->regs.sdtimer->reload);
+	write_reg(host, 1, host->regs.sdtimer->en);
+}
+
+static void litex_mmc_initsd(struct litex_mmc_host *host)
+{
+	int timeout = 20;
+	int i;
+	write_reg(host, 1 << 19, host->regs.sdcore->cmdtimeout);
+	write_reg(host, 1 << 19, host->regs.sdcore->datatimeout);
+
+	send_go_idle_cmd(host);
+
+	return 0;
+
+	/* dbg_stfu = 1; */
+
+	/* litex_timer_init(host); */
+
+	send_go_idle_cmd(host);
+	send_send_ext_csd_cmd(host);
+	/* busy_wait(1); */
+
+	/* wait for card to be ready */
+	while(timeout--) {
+		send_app_cmd(host);
+		send_app_op_cond_cmd(host, 1, 0);
+
+		if (host->resp[3] & 0x80000000) {
+			break;
+		}
+		/* busy_wait(1); */
+	}
+
+	if(timeout < 0) {
+		mlog("wait for card - F A I L E D -");
+		while(1);
+	}
+
+	send_all_send_cid_cmd(host);
+	send_set_relative_address_cmd(host, 0u);
+	send_send_cid_cmd(host);
+
+	send_send_csd_cmd(host);
+	send_select_card_cmd(host);
+
+	mlog("--------------------");
+	send_app_cmd(host);
+	send_app_set_bus_width_cmd(host, MMC_BUS_WIDTH_4);
+
+	// NOTE: switch_cmd should be called only for UHS cards
+	/* switch speed */
+	send_switch_cmd(host, SD_SWITCH_SET, SD_SWITCH_GRP_ACCESS, SD_SPEED_SDR104);
+
+	/* switch driver strength */
+	send_switch_cmd(host, SD_SWITCH_SET, SD_GROUP_DRIVERSTRENGTH, SD_DRIVER_STRENGTH_D);
+
+	/* dbg_stfu = 0; */
+	/* send scr */
+	/* send_set_blocklen_cmd(host, 8); */
+	send_app_cmd(host);
+	/* write_reg(host, 8, host->regs.sdcore->blocksize); */
+	/* write_reg(host, 1, host->regs.sdcore->blockcount); */
+	send_app_send_scr_cmd(host);
+	/* send_cmd(host, 51, 0, SDCARD_CTRL_RESPONSE_SHORT, SDCARD_CTRL_DATA_TRANSFER_READ); */
+
+	/* for(i = 0; i < 8; ++i) { */
+		/* printk(KERN_ERR "%02x \n", ioread8(host->sdread+i)); */
+	/* } */
+
+	/* set block length */
+	send_set_blocklen_cmd(host, 512);
+
+	busy_wait(100);
+
+	write_reg(host, 1 << 19, host->regs.sdcore->cmdtimeout);
+	write_reg(host, 1 << 19, host->regs.sdcore->datatimeout);
+
+	busy_wait(100);
+
+	/* dbg_stfu = 0; */
+
+	mlog("--------------------");
+
+	send_set_block_count(host, 1);
+	/* sdcard_sddatareader_start(); */
+	write_reg(host, 1, host->regs.sddatareader->reset);
+	write_reg(host, 1, host->regs.sddatareader->start);
+
+	send_read_single_block(host, 512);
+	busy_wait(100);
+
+	unsigned done = 0;
+	while((done & 1) == 0) {
+		done = read_reg(host, host->regs.sddatareader->done);
+		mlog("    done: %08x", done);
+	}
+
+	char line[17] = {0};
+	for(i = 0; i < 512; i+=16) {
+		int j;
+		for(j=0;j<16;++j) {
+			line[j] = ioread8(host->sdread+i+j);
+			if(line[j] < ' ' || line[j] >= 127) {
+				line[j] = '.';
+			}
+		}
+		line[16] = 0;
+		printk(KERN_ERR "%s\n", line);
+	}
+
+	mlog("Enough so far");
+	while(1);
+
+	mlog("--------------------");
+
+	const char sample_data[] = "SD CARD TEST";
+	mlog("Data to write: %s", sample_data);
+	iowrite8_rep(host->sdwrite, sample_data, sizeof(sample_data));
+
+	busy_wait(100);
+
+	send_set_block_count(host, 1);
+	write_reg(host, 1, host->regs.sddatawriter->reset);
+	write_reg(host, 1, host->regs.sddatawriter->start);
+	send_write_single_block_cmd(host, 10*512);
+	busy_wait(100);
+
+	done = 0;
+	while((done & 1) == 0) {
+		done = read_reg(host, host->regs.sddatawriter->done);
+		mlog("    done: %08x", done);
+	}
+	busy_wait(100);
+
+	send_stop_transmission_cmd(host);
+
+	mlog("--------------------");
+}
+
+static int __init mmc_init(void)
+{
+	printk(KERN_INFO "litex-mmc: init\n");
+	return 0;
+}
+
+static void __exit mmc_exit(void)
+{
+	printk(KERN_INFO "litex-mmc: cleanup\n");
+}
+
+module_init(mmc_init);
+module_exit(mmc_exit);
+
+/*
+ Return values for the get_ro callback should be:
+*   0 for a read/write card
+*   1 for a read-only card
+*   -ENOSYS when not supported (equal to NULL callback)
+*   or a negative errno value when something bad happened
+*/
+
+static int litex_get_ro(struct mmc_host *mmc)
+{
+	struct platform_device *pdev = to_platform_device(mmc->parent);
+	struct litex_mmc_config *config = pdev->dev.platform_data;
+	int ro;
+	mlogid();
+
+	return 0;
+
+	if (config && config->get_ro) {
+		ro = config->get_ro(pdev->id);
+	}
+	ro = mmc_gpio_get_ro(mmc);
+	mlog("ro: %d", ro);
+	return ro;
+}
+
+static int litex_get_cd(struct mmc_host *mmc)
+{
+	//int ret = mmc_gpio_get_cd(mmc);
+	struct platform_device *pdev = to_platform_device(mmc->parent);
+	struct litex_mmc_config *config = pdev->dev.platform_data;
+	mlogid();
+	if (config && config->get_cd) {
+		printk(KERN_ERR "litex-mmc: True\n");
+	}
+	return 1; //Hack - should return ret
+}
+
+#define string_for_flags(buf, flags, mask) \
+	if((flags & mask) == mask) { \
+		strcpy(buf, #mask ","); \
+		while(*(++buf)); \
+	}
+
+static const char * dbg_cmd_flags_to_string(char *buf, unsigned flags)
+{
+	char *str = buf;
+	*str = '\0';
+
+	string_for_flags(str, flags, MMC_RSP_PRESENT)
+	string_for_flags(str, flags, MMC_RSP_136)
+	string_for_flags(str, flags, MMC_RSP_CRC)
+	string_for_flags(str, flags, MMC_RSP_BUSY)
+	string_for_flags(str, flags, MMC_RSP_OPCODE)
+
+	string_for_flags(str, flags, MMC_CMD_MASK)
+	string_for_flags(str, flags, MMC_CMD_AC)
+	string_for_flags(str, flags, MMC_CMD_ADTC)
+	string_for_flags(str, flags, MMC_CMD_BC)
+	string_for_flags(str, flags, MMC_CMD_BCR)
+
+	string_for_flags(str, flags, MMC_RSP_SPI_S1)
+	string_for_flags(str, flags, MMC_RSP_SPI_S2)
+	string_for_flags(str, flags, MMC_RSP_SPI_B4)
+	string_for_flags(str, flags, MMC_RSP_SPI_BUSY)
+
+	if(str != buf) {
+		*(str-1) = '\0';
+	}
+	return buf;
+}
+
+/*
+ * Send request to a card. Command, data transfer, things like this.
+ * Call mmc_request_done() when finished.
+ */
+static void litex_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct litex_mmc_host *host = mmc_priv(mmc);
+	struct platform_device *pdev = to_platform_device(mmc->parent);
+	struct device *dev = &pdev->dev;
+	int status;
+
+	struct mmc_data *data = mrq->data;
+	struct mmc_command *cmd = mrq->cmd;
+	int retries = cmd->retries;
+
+	char flags_str[128];
+
+	u32 response_len = SDCARD_CTRL_RESPONSE_NONE;
+	u32 transfer = SDCARD_CTRL_DATA_TRANSFER_NONE;
+
+	mlogid();
+
+	if (cmd->flags & MMC_RSP_136) {
+		response_len = SDCARD_CTRL_RESPONSE_LONG;
+	} else if (cmd->flags & MMC_RSP_PRESENT) {
+		response_len = SDCARD_CTRL_RESPONSE_SHORT;
+	}
+
+	if (data) {
+		if (mrq->data->flags & MMC_DATA_READ) {
+			transfer = SDCARD_CTRL_DATA_TRANSFER_READ;
+		} else if (mrq->data->flags & MMC_DATA_WRITE) {
+			transfer = SDCARD_CTRL_DATA_TRANSFER_WRITE;
+
+			u8 data_buf[512];
+			int i;
+			sg_copy_to_buffer(data->sg, 1, data_buf, data->sg->length);
+			for (i = 0; i < data->sg->length; ++i) {
+				iowrite8(data_buf[i], &host->sdwrite[i]);
+			}
+		} else {
+			dev_warn(dev, "Data present without read or write flag.\n");
+		}
+
+		mlog("    data %s: blksize: %d, nr_blocks %d, offset 0x%8x; stopcmd=%08x, sg_len=%d, sg_count=%d",
+		     data->flags & MMC_DATA_WRITE ? "write"
+		     : data->flags & MMC_DATA_READ ? "read"
+		     : "wtf",
+		     data->blksz, data->blocks, data->sg->offset,
+		     data->stop, data->sg_len, data->sg_count);
+
+		// This is a good time (i.e. last moment) to finally set bus
+		// width. Ofc if not set yet.
+		if (!host->is_bus_width_set) {
+			mlog("Setting bus width!");
+			if (!host->app_cmd) {
+				send_app_cmd(host);
+			}
+			status = send_app_set_bus_width_cmd(host, host->bus_width);
+			if (status == SD_OK) {
+				host->is_bus_width_set = true;
+				busy_wait(10);
+			}
+			if (host->app_cmd) {
+				send_app_cmd(host);
+			}
+		}
+
+		write_reg(host, data->blksz, host->regs.sdcore->blocksize);
+		// We have 512B buffer. See if we can control clock and refill
+		// the buffer during transmission.
+		write_reg(host, 1, host->regs.sdcore->blockcount);
+	}
+
+	mlog("    cmd: %d, arg: %u (0x%08x), flags: %s",
+	     cmd->opcode, cmd->arg, cmd->arg,
+	     dbg_cmd_flags_to_string(flags_str, cmd->flags));
+	do {
+		mlog("Retries: %d", retries);
+		status = send_cmd(host, cmd->opcode, cmd->arg, response_len, transfer);
+	} while(retries-- > 0 && status != SD_OK);
+
+	// Hack: Linux repeats SD_APP_OP_COND only 4 times if there is any
+	// error. Error disappears and expected status appears after sufficient
+	// number of tries. SD spec says the command should be repeated at least
+	// for one second.
+	if (host->app_cmd && cmd->opcode == SD_APP_OP_COND
+			&& status == SD_CRCERROR) {
+		status = SD_OK;
+	}
+
+	switch(status) {
+		case SD_TIMEOUT:        cmd->error = -ETIMEDOUT; break;
+		case SD_CRCERROR:       cmd->error = -EILSEQ; break;
+		case SD_WRITEERROR:     cmd->error = -EINVAL; break;
+		default:                cmd->error = 0; break;
+	}
+
+	if (response_len == SDCARD_CTRL_RESPONSE_SHORT) {
+		// FIXME: reverse response reading
+		cmd->resp[0] = host->resp[3];
+		cmd->resp[1] = host->resp[2];
+	} else if (SDCARD_CTRL_RESPONSE_LONG) {
+		cmd->resp[0] = host->resp[0];
+		cmd->resp[1] = host->resp[1];
+		cmd->resp[2] = host->resp[2];
+		cmd->resp[3] = host->resp[3];
+	}
+
+	if (status == SD_OK && transfer == SDCARD_CTRL_DATA_TRANSFER_READ) {
+		u8 data_buf[512];
+		int i;
+
+		data->bytes_xfered = data->blksz <= 512 ? data->blksz : 512;
+		for (i = 0; i < data->bytes_xfered; ++i) {
+			data_buf[i] = ioread8(host->sdread+i);
+		}
+		sg_copy_from_buffer(data->sg, 1, data_buf, data->bytes_xfered);
+	} else if (status == SD_OK && transfer == SDCARD_CTRL_DATA_TRANSFER_WRITE) {
+		// XXX: needed?
+		data->bytes_xfered = data->blksz <= 512 ? data->blksz : 512;
+	}
+
+	host->app_cmd = (cmd->opcode == MMC_APP_CMD && status == SD_OK);
+
+	mmc_request_done(mmc, mrq);
+}
+
+#define string_case(val) case val: return #val ;
+
+static const char * power_mode_to_string(unsigned char pm)
+{
+	switch(pm) {
+	string_case(MMC_POWER_OFF)
+	string_case(MMC_POWER_UP)
+	string_case(MMC_POWER_ON)
+	string_case(MMC_POWER_UNDEFINED)
+	}
+}
+static const char * timing_to_string(unsigned char t)
+{
+	switch(t) {
+		string_case(MMC_TIMING_LEGACY)
+		string_case(MMC_TIMING_MMC_HS)
+		string_case(MMC_TIMING_SD_HS)
+		string_case(MMC_TIMING_UHS_SDR12)
+		string_case(MMC_TIMING_UHS_SDR25)
+		string_case(MMC_TIMING_UHS_SDR50)
+		string_case(MMC_TIMING_UHS_SDR104)
+		string_case(MMC_TIMING_UHS_DDR50)
+		string_case(MMC_TIMING_MMC_DDR52)
+		string_case(MMC_TIMING_MMC_HS200)
+		string_case(MMC_TIMING_MMC_HS400)
+	}
+}
+
+static void litex_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct litex_mmc_host *host = mmc_priv(mmc);
+	struct platform_device *pdev = to_platform_device(mmc->parent);
+	struct litex_mmc_config *config = pdev->dev.platform_data;
+	int status;
+	mlogid();
+
+	mlog("clk %dHz, busmode %d, powermode %s, vdd %d, timing %s, delay %u",
+	     ios->clock,
+	     ios->bus_mode,
+	     power_mode_to_string(ios->power_mode),
+	     ios->vdd,
+	     timing_to_string(ios->timing),
+	     ios->power_delay_ms);
+
+	switch (ios->power_mode) {
+	case MMC_POWER_UP:
+		return;
+	}
+
+	if (ios->clock != host->clock) {
+		sdclk_set_clk((ios->clock / (u32)1e6));
+		host->clock = ios->clock;
+	}
+
+	// Technically there should be some code for setting requested bus width.
+	// We can't send "send_bus_width" command to the card at this moment
+	// because the card is not in the right state (the command is only accepted
+	// in "trans" state). Requested width should be stored and send when it is
+	// possible (see litex_request), but litesdcard supports only 4 bit bus
+	// width, so it is known what must be set.
+
+	busy_wait(10);
+}
+
+static const struct mmc_host_ops litex_mmc_ops = {
+
+	.get_cd = litex_get_cd,
+	.get_ro = litex_get_ro,
+	.request = litex_request,
+	.set_ios = litex_set_ios,
+};
+
+static int litex_mmc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct litex_mmc_host *host;
+	struct device_node *node;
+	struct mmc_host *mmc;
+	int ret;
+	int i;
+
+	static const size_t resource_ptr_offsets[] = {
+		offsetof(struct litex_mmc_host, regs.sdclk),
+		offsetof(struct litex_mmc_host, regs.sdcore),
+		offsetof(struct litex_mmc_host, regs.sddatareader),
+		offsetof(struct litex_mmc_host, regs.sddatawriter),
+		offsetof(struct litex_mmc_host, sdread),
+		offsetof(struct litex_mmc_host, sdwrite),
+		offsetof(struct litex_mmc_host, regs.sdtimer),
+	};
+
+	printk(KERN_ERR "litex-mmc: probe\n");
+	node = pdev->dev.of_node;
+	if (!node) {
+		printk(KERN_ERR "litex-mmc: No device_node...\n");
+		return -ENODEV;
+	}
+
+	host = devm_kzalloc(&pdev->dev, sizeof(struct litex_mmc_host),
+			    GFP_KERNEL);
+	if (!host) {
+		printk(KERN_ERR "litex-mmc: Not enough memory...\n");
+		return -ENOMEM;
+	}
+
+	mmc = mmc_alloc_host(sizeof(struct litex_mmc_host), &pdev->dev);
+	if (!mmc) {
+		printk(KERN_ERR "litex-mmc: No mmc...\n");
+		return -ENOMEM;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	// Initial state
+	host->clock = 0;
+	// litesdcard only supports 4-bit bus width
+	host->bus_width = MMC_BUS_WIDTH_4;
+	host->is_bus_width_set = false;
+	host->app_cmd = false;
+
+	for (i = 0; i < ARRAY_SIZE(resource_ptr_offsets); ++i) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res) {
+			dev_err(&pdev->dev, "Resource %d missing\n", i);
+			ret = -ENODEV;
+			goto err_exit;
+		}
+		*(void **)((char *)host + resource_ptr_offsets[i]) =
+			devm_ioremap_resource(&pdev->dev, res);
+		if (!(*(void **)((char *)host + resource_ptr_offsets[i]))) {
+			dev_err(&pdev->dev, "Couldn't map resource %d\n", i);
+			ret = -ENOMEM;
+			goto err_exit;
+		}
+	}
+
+	ret = mmc_of_parse(mmc);
+	if (ret) {
+		printk(KERN_ERR "litex-mmc: Parse error\n");
+		goto err_exit;
+	}
+
+	/* host->mmc_input_clk = (u32)(SD_CLOCK_FREQUENCY * 1e6); */
+	printk(KERN_ERR "litex-mmc: Setting clock to %d", SD_CLOCK_FREQUENCY);
+	sdclk_set_clk(SD_CLOCK_FREQUENCY);
+	litex_mmc_initsd(host);
+
+	mmc->caps = 0//MMC_CAP_WAIT_WHILE_BUSY
+		| MMC_CAP_DRIVER_TYPE_D;
+	mmc->caps2 = MMC_CAP2_NO_SDIO | MMC_CAP2_FULL_PWR_CYCLE | MMC_CAP2_NO_WRITE_PROTECT;
+	mmc->ops = &litex_mmc_ops;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	mmc->max_segs = MAX_NR_SG;
+	mmc->max_seg_size = 512;
+	mmc->max_blk_size = 512;
+	mmc->max_blk_count = 1;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+
+	mmc->f_min = SD_CLOCK_FREQUENCY  * 1e6;
+	mmc->f_max = SD_CLOCK_FREQUENCY  * 1e6;
+
+	printk(KERN_ERR "litex-mmc: platform_set_drvdata");
+	platform_set_drvdata(pdev, host);
+
+	ret = mmc_add_host(mmc);
+	if (ret < 0) {
+		goto err_exit;
+	}
+
+	printk(KERN_ERR "litex-mmc: finished probe\n");
+	return 0;
+
+err_exit:
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int litex_mmc_remove(struct platform_device *pdev)
+{
+	struct litex_mmc_host *host = dev_get_drvdata(&pdev->dev);
+
+	mmc_remove_host(host->mmc);
+	mmc_free_host(host->mmc);
+
+	printk(KERN_ERR "removed device\n");
+	return 0;
+}
+
+static const struct of_device_id litex_match[] = {
+	{ .compatible =
+		"litex,mmc" },
+		{}
+	};
+
+MODULE_DEVICE_TABLE(of, litex_match);
+
+static struct platform_driver litex_mmc_driver = {
+	.driver =
+		{
+			.name = "litex-mmc",
+			.of_match_table = of_match_ptr(litex_match),
+		},
+	.probe = litex_mmc_probe,
+	.remove = litex_mmc_remove,
+};
+
+module_platform_driver(litex_mmc_driver);
+
+MODULE_DESCRIPTION("LiteX SDCard driver");
+MODULE_AUTHOR("Antmicro <www.antmicro.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.23.0

